Am definit o constanta,DIM(36), reprezentand dimensiunea alfabetului + numarul cifrelor.

Am definit structurile TNod si TTrie.Variabila flag din cadrul structurii TNod avand urmatoarea semnificatie:este 1 daca in nodul respectiv se termina un cuvant si 0 daca in nodul respectiv nu se termina niciun cuvant.

Am definit o functie TRANSFORMA care imi calculeaza indicele unui nod in functie de caracterul asociat lui.Astfel verific dupa codul ASCII daca caracterul dat ca parametru e cifra sau litera iar nodurile care au asociate litere vor avea indici de la 10 la 35 iar nodurile care au asociate cifre vor avea indici de la 0 la 9.

Functia AlocaNod imi aloca memorie pentru un nod nou,campul flag al nodului fiind initializat cu 0,intrucat deocamdata nu se termina niciun cuvant in respectivul nod iar fiii sunt si ei initializati cu NULL,intrucat cel putin deocamdata noul nod nu are inserat niciun fiu.

Functia InitializareTrie apeleaza functia AlocaNod,alocand astfel radacina trie-ului.

In functia add stochez lungimea cuvantului de adaugat in variabila lungime.Imi iau un pointer de tip TNod numit r pe care il initializez cu radacina trie-ului.Apoi parcurg cu un for un numar de nivele egal cu lungimea cuvantului.In variabila ind voi avea indicele corespunzator caracterului de pe pozitia cuvant[nivel].De fiecare data verific cu un if daca in campul fii[ind] al nodului curent se se afla sau nu un nod iar in cazul in care nu se afla aloc un nou nod.Dupa ce am facut aceasta verificare avansez in trie pe calea data de nodul r->fii[ind],nodul curent r luand valoarea r->fii[ind].Dupa ce am parcurs toate nivelele,in final voi marca campul flag al nodului curent r cu valoarea 1 pentru a semnaliza terminarea unui cuvant in respectivul nod.

Functia find va fi de tip int,rezultatul sau fiind 1 daca cuvantul dat ca parametru se afla in trie si respectiv 0 daca cuvantul dat ca parametru nu se afla in trie.La fel ca la functia add imi iau un pointer r de tip TNod pentru a parcurge trie-ul,pointer pe care il initializez cu radacina trie-ului.Pentru a imi da seama daca cuvantul dat ca parametru se gaseste in trie trebuie sa parcurg cel mult un numar de nivele egal cu lungimea cuvantului.Daca pe pozitia ind a vectorului de fii al nodului curent r nu se gaseste un nod acest lucru echivaleaza cu faptul ca cel putin un caracter din cuvantul dat ca parametru lipseste,deci cuvantul nu se regaseste in trie,iar functia returneaza 0.Altfel daca in r->fii[ind] se gaseste un nod,avansez in trie r luand valoarea r->fii[ind].Dupa ce am parcurs un numar de nivele egal cu lungimea cuvantului dat ca parametru, daca r e diferit de NULL si r->flag este 1,deci aici se termina un cuvant,asta inseamna ca respectivul se gaseste in trie.

In functia find_longest_prefix initializez prefixul cu "N".Imi iau din nou un pointer r pentru parcurgerea trie-ului pe care il initializez cu radacina trie-ului.Apoi introduc din nou un for care va itera de cel mult un numar egal cu lungimea cuvantului,intrucat cel mai lung prefix posibil are lungimea egala cu lungimea cuvantului.Daca nodul curent r nu are un fiu pe pozitia ind asta inseamna ca rezultatul pe care va trebui sa il intoarca functia este chiar prefixul constituit pana la momentul curent.Dar inainte de a intoarce acest rezultat mai fac o verificare daca nodul curent este chiar radacina trie-ului,iar in caz ca este radacina trie-ului atunci copiez "None" peste "N",pentru ca functia sa imi intoarca "None" intrucat inseamna ca cuvantul dat ca parametru nu are niciun prefix comun cu vreun cuvant din trie.Daca nu s-a returnat prefixul din if-ul anterior asta inseamna ca am (mai) gasit un caracter in comun si programul imi va intra pe un alt if care verifica daca prefixul curent este "N" sau nu.Daca da,atunci inlocuiesc prefixul cu sirul vid si apoi copiez caracterul corespunzator lui cuvant[nivel] peste sirul vid.Daca prefixul curent nu este "N" atunci pur si simplu voi concatena prefixul curent cu caracterul corespunzator lui cuvant[nivel].
Mai apoi avansez in trie,r luand valoarea r->fii[ind].Dupa ce se termina for-ul mai fac un if,iar daca r e diferit de NULL si r->flag este 1,deci aici se termina cuvantul,voi intoarce prefixul care practic va fi chiar cuvantul dat ca parametru.In final eliberez memoria alocata pentru prefix.

Functia enodtermcuv verifica daca flag-ul e 1 sau 0.Intoarce asadar 1 daca in nodul dat ca parametru se termina un cuvant si respectiv 0 daca in nodul dat ca parametru nu se termina niciun cuvant.

Functia efrunza verifica daca nodul dat ca parametrii are fii sau nu.Intoarce 1 daca nodul dat ca parametru e frunza si 0 daca nodul dat ca parametru nu e frunza.

Pentru a scoate un cuvant din trie,am creat doua functii.Functia auxiliara auxremove verifica daca nodul dat ca parametru e diferit de NULL,iar daca da verifica daca nivelul este egal cu lungimea cuvantului dat ca parametru.Daca nivelul este egal cu lungimea cuvantului dat ca parametru atunci se verifica daca flag-ul nodului ecste 1 si daca da atunci flag-ul va deveni 0 pentru a simboliza faptul ca in respectivul nod nu se mai termina niciun cuvant si mai fac o verificare daca nodul a devenit frunza,intorcandu-se true sau false dupa caz.Daca lungimea nodului este diferita decat nivel dat ca parametru,tinand cont de faptul ca nivelul dat ca parametru din removew este 0 ,acest lucru inseamna ca vom avea mai multe noduri de sters si vom calcula din nou un indice ind care va lua valoarea TRANSFORMA(cuvant[nivel]).Apelez recursiv functia auxremove pentru parametrii p->fii[ind],cuvant,nivel+1,lungime iar daca rezuLtatul este true atunci eliberez memoria pentru p->fii[ind].In cadrul acestui ultim if mai verific si daca nodul este frunza dar in el nu se mai termina niciun cuvant si daca da atunci returnez true,altfel returnez false.Daca parametrul p dat prima data in functia auxremove este NULL atunci returnez false.
In functia removew verific daca lungimea cuvantului dat ca parametru este pozitiva,pentru ca doar in acest caz mai are rost sa apelez functia auxremove.Apelez functia auxremove cu parametrii p->radacina,cuvant,0,lungime deoarece vrea sa pornesc in stergere de la radacina trie-ul,de pe nivelul 0.

In vederea obtinerii unui rezultat pentru functia find_all_with_prefix am mai creat alte 3 functii auxiliare.Functia count_words_with_prefix imi coboara pe trie prin intermediul unui for pana la nodul corespunzand ultimului caracter din prefix.In intermediul functiei count_words_with_prefix prin apeluri recursive realizez un DFS astfel incat parcurg tot subtrie-ul si de fiecare data cand gasesc un cuvant (flag=1) adaug 1 la count.In functia auxfind iterez printre fiii cate unui nivel si calculez caracterul tinand cont de indicele nodului dat ca parametru si anexez respectivul caracter la posibilcuvant.Daca flag-ul este 1 inseamna ca posibilcuvant chiar e cuvant.Apelez auxfind pentru urmatorul nivel pentru a itera si printre fiii acestui nivel.In functia find_all_with_prefix memorez in rezlen numarul cuvintelor care incep cu prefix si aloc memorie pentru rezlen cuvinte.Apoi interez printre caracterele lui prefix prin intermediul unui for.Daca nodul asociat unui caracter din prefix nu exista acest lucru inseamna implicit ca nu exista niciun cuvant cu respectivul prefix in trie-ul dat si in acest caz voi pune in rez[0] cuvantul "None" dupa care voi returna rez.In cazul in care am ajuns cu r la ultimul caracter din prefix voi verifica daca in acel nod se termina un cuvant si daca da atunci il voi retine in rez[contor] iar contorul va creste cu 1.In final copiez prefix peste posibil cuvant si apelez auxfind de posibilcuvant,etc.

In functia mean_length retin in rez cuvintele intoarse de functia find_all_with prefix apelata cu acelasi prefix.Parcurg rez si la suma curenta adaug lungimea cuvantului curent.In final obtin suma lungimilor tuturor cuvintelor care incep cu prefix iar pentru a obtine media impart suma la numarul de cuvinte.



